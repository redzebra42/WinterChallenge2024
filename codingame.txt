#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <fstream>
#include <map>
#include <cmath>

using namespace std;

/**
 * 
 **/

struct Entity
{
    int x, y, id, owner, organ_id, organ_parent_id, organ_root_id;
    string type, organ_dir;
    Entity() :
        x(0),
        y(0),
        type("NONE"),
        owner(0),
        organ_id(0),
        organ_dir("NONE"),
        organ_parent_id(0),
        organ_root_id(0) {}
    Entity(int _x, int _y, string _type, int _owner, int _organ_id, string _organ_dir, int _organ_parent_id, int _organ_root_id) : 
        x(_x),
        y(_y),
        type(_type),
        owner(_owner),
        organ_id(_organ_id),
        organ_dir(_organ_dir),
        organ_parent_id(_organ_parent_id),
        organ_root_id(_organ_root_id) {}
};

// Euclidian distance squared (because just used for comparing)
int distance(const Entity &ent1, const Entity &ent2)
{
    return (pow(ent1.x - ent2.x, 2) + pow(ent1.y - ent2.y, 2));
}

// organ and protein closest to each other (1:my, 0:opp)
int closestOrgan(Entity *&closest_organ, Entity *&closest_protein, int player, const string &protein_type, const map<string, vector<Entity*>> &entities)
{
    int dist_min = numeric_limits<int>::max();
    vector<Entity*> organs;
    if (player == 1)
    {
        organs = entities.at("MY_ORGAN"); // maybe error because of const
    }
    else if (player == 0)
    {
        organs = entities.at("OPP_ORGAN"); // maybe error because of const
    }
    else 
    {
        cerr << "player should be 0 or 1" << endl;
    }
    vector<Entity*> proteins = entities.at(protein_type);
    for (Entity *organ : organs)
    {
        for (Entity *protein : proteins)
        {
            int new_dist = distance(organ, protein);
            if ( new_dist < dist_min)
            {
                dist_min = new_dist;
                closest_organ = organ;
                closest_protein = protein;
            }
        }
    }
    return dist_min;
}

int main()
{
    int width; // columns in the game grid
    int height; // rows in the game grid
    cin >> width >> height; cin.ignore();
    vector<vector<Entity*>> room(height, vector<Entity*>(width, nullptr));

    // game loop
    while (1) {
        int entity_count;
        cin >> entity_count; cin.ignore();
        map<string, vector<Entity*>> entities;
        for (int i = 0; i < entity_count; i++)
        {
            int x;
            int y; // grid coordinate
            string type; // 0 WALL, 1 ROOT, 2 BASIC, 3 TENTACLE, 4 HARVESTER, 5 SPORER, 6 A, 7 B, 8 C, 9 D
            int owner; // 1 if your organ, 0 if enemy organ, -1 if neither
            int organ_id; // id of this entity if it's an organ, 0 otherwise
            string organ_dir; // N,E,S,W or X if not an organ
            int organ_parent_id;
            int organ_root_id;
            cin >> x >> y >> type >> owner >> organ_id >> organ_dir >> organ_parent_id >> organ_root_id; cin.ignore();
            Entity *new_entity = new Entity(x, y, type, owner, organ_id, organ_dir, organ_parent_id, organ_root_id);
            if (owner == 1)
            {
                entities["MY_ORGAN"].push_back(new_entity);
            }
            else if (owner == 0)
            {
                entities["OPP_ORGAN"].push_back(new_entity);
            }
            else
            {
                entities[type].push_back(new_entity);
            }
            room[y][x] = new_entity;
        }
        vector<int> my_proteins(4, 0), opp_proteins(4, 0);
        cin >> my_proteins[0] >> my_proteins[1] >> my_proteins[2] >> my_proteins[3]; cin.ignore(); // your protein stock
        cin >> opp_proteins[0] >> opp_proteins[1] >> opp_proteins[2] >> opp_proteins[3]; cin.ignore(); // opponent's protein stock
        int required_actions_count; // your number of organisms, output an action for each one in any order
        cin >> required_actions_count; cin.ignore();

        // find the best organ to make
        Entity *closest_organ, *closest_protein;
        closestOrgan(closest_organ, closest_protein, 1, "A", entities);

        for (int i = 0; i < required_actions_count; i++)
        {
            if (my_proteins[0] == 0)
            {
                cout << "WAIT" << endl;
            }
            else
            {
                // grow organ with the chosen organ and protein
                cout << "GROW " << closest_organ->organ_id << " " << closest_protein->x << " " << closest_protein->y << " BASIC" << endl;
            }
        break;
        }
    }
}

